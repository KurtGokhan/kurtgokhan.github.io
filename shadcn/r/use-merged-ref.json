{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-merged-ref",
  "title": "useMergedRef Hook",
  "description": "Merge multiple React refs into a single stable callback ref.",
  "files": [
    {
      "path": "registry/default/hooks/use-merged-ref.ts",
      "content": "import { useCallback, useRef } from 'react';\nimport type { MutableRefObject, Ref, RefCallback } from 'react';\n\ntype PossibleRef<T> = Ref<T> | undefined | null;\n\nfunction setRef<T>(ref: PossibleRef<T>, value: T | null) {\n  if (!ref) return;\n  if (typeof ref === 'function') {\n    (ref as RefCallback<T | null>)(value);\n    return;\n  }\n\n  (ref as MutableRefObject<T | null>).current = value;\n}\n\nfunction refsEqual<T>(a: PossibleRef<T>[], b: PossibleRef<T>[]) {\n  if (a === b) return true;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!Object.is(a[i], b[i])) return false;\n  }\n  return true;\n}\n\n/**\n * Merge multiple refs into a single ref callback.\n * Handy when you need to forward a ref while also keeping an internal reference.\n */\nexport function useMergedRef<T>(...refs: PossibleRef<T>[]) {\n  const refsRef = useRef(refs);\n  if (!refsEqual(refsRef.current, refs)) {\n    refsRef.current = refs;\n  }\n\n  return useCallback<RefCallback<T | null>>((value) => {\n    for (const ref of refsRef.current) setRef(ref, value);\n  }, []);\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}