{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "deferred",
  "title": "Deferred Promise",
  "description": "A Promise subclass that can be resolved or rejected externally, with status tracking, timeout, and polling support.",
  "files": [
    {
      "path": "registry/default/lib/deferred.ts",
      "content": "export type DeferredExecutor<T> = (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: unknown) => void\n) => void;\n\n/**\n * A Promise that can be resolved or rejected by external code.\n * It also exposes the status of the promise, and resolved value or the rejection error.\n */\nexport class Deferred<T = unknown> extends Promise<T> {\n  status: 'pending' | 'resolved' | 'rejected' = 'pending';\n\n  /**\n   * A method to resolve the associated Promise with the value passed.\n   * If the promise is already settled it does nothing.\n   *\n   * @param {anything} value : This value is used to resolve the promise\n   * If the value is a Promise then the associated promise assumes the state\n   * of Promise passed as value.\n   */\n  resolve: (value: T | PromiseLike<T>) => void;\n\n  /**\n   * A method to reject the assocaited Promise with the value passed.\n   * If the promise is already settled it does nothing.\n   *\n   * @param {anything} reason: The reason for the rejection of the Promise.\n   * Generally its an Error object. If however a Promise is passed, then the Promise\n   * itself will be the reason for rejection no matter the state of the Promise.\n   */\n  reject: (reason?: unknown) => void;\n\n  /**\n   * Required when extending Promise class\n   */\n  static get [Symbol.species]() {\n    return Promise;\n  }\n\n  /**\n   * The value with which the promise was resolved\n   */\n  value?: T;\n\n  /**\n   * The error with which the promise was rejected\n   */\n  error?: unknown;\n\n  /**\n   * Creates a promise that is resolved after {amount} milliseconds\n   */\n  static timeout<T = void>(\n    amount?: number,\n    executor?: DeferredExecutor<T | void>,\n    rejectOnTimeout = false,\n    signal?: AbortSignal\n  ) {\n    const df = new Deferred(executor);\n    if (Number.isFinite(amount)) {\n      const timeout = setTimeout(() => (rejectOnTimeout ? df.reject() : df.resolve()), amount);\n      signal?.addEventListener('abort', () => clearTimeout(timeout));\n    }\n    return df;\n  }\n\n  /**\n   * Creates a promise that periodically checks if a condition returns true and then returns true.\n   * If the condition does not return true within the given timeout duration, returns false.\n   */\n  static async polling(checkCondition: (passedTime: number) => boolean, interval: number, timeout?: number) {\n    const df = new Deferred<boolean>();\n\n    const initTime = Date.now();\n\n    if (checkCondition(0)) df.resolve(true);\n\n    const intervalInstance = setInterval(() => {\n      if (checkCondition(Date.now() - initTime)) df.resolve(true);\n    }, interval);\n\n    const res = timeout ? Promise.race<boolean>([Deferred.timeout(timeout).then(() => false), df]) : df;\n    res.catch().then(() => clearInterval(intervalInstance));\n    return res;\n  }\n\n  /**\n   * A newly created Promise object.\n   * Initially in pending state.\n   */\n  constructor(executor?: DeferredExecutor<T>) {\n    let rs: (value: T | PromiseLike<T>) => void;\n    let rj: (reason?: unknown) => void;\n\n    super((resolve, reject) => {\n      rs = resolve;\n      rj = reject;\n      return executor?.(resolve, reject);\n    });\n\n    this.resolve = rs!;\n    this.reject = rj!;\n\n    (async () => {\n      try {\n        const res = await this;\n        this.value = res;\n        this.status = 'resolved';\n      } catch (e) {\n        this.error = e;\n        this.status = 'rejected';\n      }\n    })();\n  }\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}